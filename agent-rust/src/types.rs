use crate::AgentError;
use futures::{stream::BoxStream, Stream};
use llm_sdk::{Message, Part, PartialModelResponse};
use serde::{Deserialize, Serialize};
use std::{
    pin::Pin,
    task::{Context, Poll},
};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentRequest<TCtx> {
    /// The input items to the agent, such as LLM messages.
    pub input: Vec<AgentItem>,
    /// The context to be used during tool calling and building system
    /// instructions
    pub context: TCtx,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentResponse {
    /// The items generated during the agent's execution, such as new
    /// `ToolMessage` and `AssistantMessage`
    pub output: Vec<AgentItem>,

    /// The last assistant output content generated by the agent.
    pub content: Vec<Part>,
}

impl AgentResponse {
    /// Extract all text content from the final content, separated by a space.
    pub fn text(&self) -> String {
        self.content
            .iter()
            .filter_map(|part| match part {
                Part::Text(part) => Some(part.text.as_str()),
                _ => None,
            })
            .collect::<Vec<_>>()
            .join(" ")
    }
}

/// An input for or output entry generated by the agent run
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum AgentItem {
    /// A LLM message used in the run
    Message(Message),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum AgentStreamEvent {
    Partial(PartialModelResponse),
    Message(Message),
    Response(AgentResponse),
}

pub struct AgentStream(BoxStream<'static, Result<AgentStreamEvent, AgentError>>);

impl AgentStream {
    pub fn from_stream<S>(stream: S) -> Self
    where
        S: Stream<Item = Result<AgentStreamEvent, AgentError>> + Send + 'static,
    {
        Self(Box::pin(stream))
    }
}

impl Stream for AgentStream {
    type Item = Result<AgentStreamEvent, AgentError>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        self.0.as_mut().poll_next(cx)
    }
}
