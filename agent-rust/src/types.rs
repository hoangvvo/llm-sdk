use std::{
    pin::Pin,
    task::{Context, Poll},
};

use futures::{stream::BoxStream, Stream};
use llm_sdk::{Message, Part, PartialModelResponse};
use serde::{Deserialize, Serialize};

use crate::AgentError;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentRequest<TCtx> {
    /// The input messages to the agent.
    pub messages: Vec<Message>,
    /// The context to be used during tool calling and building system
    /// instructions
    pub context: TCtx,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentResponse {
    /// The chain of messages generated during the agent's execution.
    pub new_messages: Vec<Message>,

    /// The last assistant output content generated by the agent.
    pub content: Vec<Part>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum AgentStreamEvent {
    Partial(PartialModelResponse),
    Message(Message),
    Response(AgentResponse),
}

pub struct AgentStream(BoxStream<'static, Result<AgentStreamEvent, AgentError>>);

impl AgentStream {
    pub fn from_stream<S>(stream: S) -> Self
    where
        S: Stream<Item = Result<AgentStreamEvent, AgentError>> + Send + 'static,
    {
        Self(Box::pin(stream))
    }
}

impl Stream for AgentStream {
    type Item = Result<AgentStreamEvent, AgentError>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        self.0.as_mut().poll_next(cx)
    }
}
