---
title: Tools
---

import { Aside, Code, TabItem, Tabs } from "@astrojs/starlight/components";
import goToolsExample from "../../../../../agent-go/examples/tools/main.go?raw";
import jsToolsExample from "../../../../../agent-js/examples/tools.ts?raw";
import rustToolsExample from "../../../../../agent-rust/examples/tools.rs?raw";
import {
  extractGoAgentToolTypes,
  extractRustAgentToolTypes,
  extractTypescriptAgentToolTypes,
} from "../../../utils/extract-types.ts";

Tools let the model delegate work to your code. Each definition bundles a `name`, a short `description` that teaches the model when to call it, a JSON Schema `parameters` object, and an `execute` handler that receives `(args, context, state)`. The handler must return an `AgentToolResult` so the agent can stream success or failure back into the conversation.

Use descriptive verbs for names (`search_docs`, `create_ticket`) and write the description as if you were coaching the model. Parameters should only include data the model can realistically supply. If you need to resolve identifiers or fetch additional state, do so inside `execute` where you still have access to the run session `context` and the full `RunState` history.

<Aside type="danger">
  Avoid exposing immutable data as tool parameters. If a parameter controls access (for example, `current_user_id` or `account_id`), a malicious prompt or jailbreak might coerce the model into supplying a forged value. Instead, keep those values in the context object and read them inside `execute` so the model can never override them.
</Aside>

<Tabs>
  <TabItem label="TypeScript">
    <Code
      code={extractTypescriptAgentToolTypes(["AgentTool", "AgentToolResult"])}
      lang="typescript"
      title="types.ts"
    />
  </TabItem>
  <TabItem label="Rust">
    <Code
      code={extractRustAgentToolTypes(["AgentTool", "AgentToolResult"])}
      lang="rust"
      title="types.rs"
    />
  </TabItem>
  <TabItem label="Go">
    <Code
      code={extractGoAgentToolTypes(["AgentTool", "AgentToolResult"])}
      lang="go"
      title="types.go"
    />
  </TabItem>
</Tabs>

Return structured [`Part[]`](../../sdk/language-model#part) content so multimodal models can relay text, images, or audio results. Set `is_error` to `true` when you want the model to acknowledge a failure instead of halting the run with an exception.

<Aside type="note">
  If an error is thrown inside `execute`, the run will stop and the error will propagate to your code. This also prevents leaking [internal stack traces, dumps, or other sensitive information](https://owasp.org/www-community/Improper_Error_Handling) to the model and ultimately to the user.
  If you intend for the model to see your operational errors (for example, "not found" or "permission denied"), return them as `TextPart` inside the `AgentToolResult` and set `is_error: true`.
</Aside>

## Example

The examples below show simple tools in each SDK, including how to wire them into an agent.

<Tabs>
  <TabItem label="TypeScript">
    <Code code={jsToolsExample} lang="typescript" title="tools.ts" />
  </TabItem>
  <TabItem label="Rust">
    <Code code={rustToolsExample} lang="rust" title="tools.rs" />
  </TabItem>
  <TabItem label="Go">
    <Code code={goToolsExample} lang="go" title="main.go" />
  </TabItem>
</Tabs>
