use serde::{Deserialize, Serialize};
use serde_json::Value;

/// The parameters for creating a message
#[derive(Serialize, Deserialize)]
pub struct CreateMessageParams {
    /// The maximum number of tokens to generate before stopping
    pub max_tokens: u32,

    /// Input messages
    pub messages: Vec<InputMessage>,

    /// An object describing metadata about the request
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,

    /// The model that will complete your prompt
    pub model: Model,

    /// Determines whether to use priority capacity or standard capacity
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_tier: Option<ServiceTier>,

    /// Custom text sequences that will cause the model to stop generating
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop_sequences: Option<Vec<String>>,

    /// Whether to incrementally stream the response using server-sent events
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream: Option<bool>,

    /// System prompt
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system: Option<SystemPrompt>,

    /// Amount of randomness injected into the response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f64>,

    /// Configuration for enabling Claude's extended thinking
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thinking: Option<ThinkingConfigParam>,

    /// How the model should use the provided tools
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<ToolChoice>,

    /// Definitions of tools that the model may use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<ToolUnion>>,

    /// Only sample from the top K options for each subsequent token
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_k: Option<u32>,

    /// Use nucleus sampling
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f64>,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemPrompt {
    String(String),
    Blocks(Vec<RequestTextBlock>),
}

/// The response message
#[derive(Serialize, Deserialize)]
pub struct Message {
    /// Content generated by the model
    pub content: Vec<ContentBlock>,

    /// Unique object identifier
    pub id: String,

    /// The model that generated the response
    pub model: Model,

    /// Conversational role of the generated message
    #[serde(default = "default_assistant_role")]
    pub role: String,

    /// The reason that we stopped
    pub stop_reason: Option<StopReason>,

    /// Which custom stop sequence was generated, if any
    pub stop_sequence: Option<String>,

    /// Object type
    #[serde(rename = "type", default = "default_message_type")]
    pub type_field: String,

    /// Billing and rate-limit usage
    pub usage: Usage,
}

fn default_assistant_role() -> String {
    "assistant".to_string()
}

fn default_message_type() -> String {
    "message".to_string()
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum MessageStreamEvent {
    #[serde(rename = "message_start")]
    MessageStart(MessageStartEvent),

    #[serde(rename = "message_delta")]
    MessageDelta(MessageDeltaEvent),

    #[serde(rename = "message_stop")]
    MessageStop(MessageStopEvent),

    #[serde(rename = "content_block_start")]
    ContentBlockStart(ContentBlockStartEvent),

    #[serde(rename = "content_block_delta")]
    ContentBlockDelta(ContentBlockDeltaEvent),

    #[serde(rename = "content_block_stop")]
    ContentBlockStop(ContentBlockStopEvent),

    #[serde(rename = "ping")]
    Ping(PingEvent),

    #[serde(other)]
    Unknown,
}

#[derive(Serialize, Deserialize)]
pub struct PingEvent {}

#[derive(Serialize, Deserialize)]
pub struct MessageStartEvent {
    pub message: Message,
}

#[derive(Serialize, Deserialize)]
pub struct MessageDeltaEvent {
    pub delta: MessageDelta,
    pub usage: MessageDeltaUsage,
}

#[derive(Serialize, Deserialize)]
pub struct MessageStopEvent {}

#[derive(Serialize, Deserialize)]
pub struct ContentBlockStartEvent {
    pub content_block: ContentBlock,
    pub index: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ContentBlockDeltaEvent {
    pub delta: ContentBlockDelta,
    pub index: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ContentBlockStopEvent {
    pub index: u32,
}

#[derive(Serialize, Deserialize)]
pub struct InputMessage {
    pub content: InputMessageContent,
    pub role: String,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum InputMessageContent {
    String(String),
    Blocks(Vec<InputContentBlock>),
}

#[derive(Serialize, Deserialize)]
pub struct Metadata {
    /// An external identifier for the user who is associated with the request
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<String>,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum Model {
    String(String),
    Variant(ModelVariant),
}

#[derive(Serialize, Deserialize)]
pub enum ModelVariant {
    #[serde(rename = "claude-3-7-sonnet-latest")]
    Claude37SonnetLatest,
    #[serde(rename = "claude-3-7-sonnet-20250219")]
    Claude37Sonnet20250219,
    #[serde(rename = "claude-3-5-haiku-latest")]
    Claude35HaikuLatest,
    #[serde(rename = "claude-3-5-haiku-20241022")]
    Claude35Haiku20241022,
    #[serde(rename = "claude-sonnet-4-20250514")]
    ClaudeSonnet420250514,
    #[serde(rename = "claude-sonnet-4-0")]
    ClaudeSonnet40,
    #[serde(rename = "claude-4-sonnet-20250514")]
    Claude4Sonnet20250514,
    #[serde(rename = "claude-3-5-sonnet-latest")]
    Claude35SonnetLatest,
    #[serde(rename = "claude-3-5-sonnet-20241022")]
    Claude35Sonnet20241022,
    #[serde(rename = "claude-3-5-sonnet-20240620")]
    Claude35Sonnet20240620,
    #[serde(rename = "claude-opus-4-0")]
    ClaudeOpus40,
    #[serde(rename = "claude-opus-4-20250514")]
    ClaudeOpus420250514,
    #[serde(rename = "claude-4-opus-20250514")]
    Claude4Opus20250514,
    #[serde(rename = "claude-opus-4-1-20250805")]
    ClaudeOpus4120250805,
    #[serde(rename = "claude-3-opus-latest")]
    Claude3OpusLatest,
    #[serde(rename = "claude-3-opus-20240229")]
    Claude3Opus20240229,
    #[serde(rename = "claude-3-haiku-20240307")]
    Claude3Haiku20240307,
}

#[derive(Serialize, Deserialize)]
pub enum ServiceTier {
    #[serde(rename = "auto")]
    Auto,
    #[serde(rename = "standard_only")]
    StandardOnly,
}

#[derive(Serialize, Deserialize)]
pub struct RequestTextBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub citations: Option<Vec<RequestCitation>>,

    pub text: String,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ThinkingConfigParam {
    #[serde(rename = "enabled")]
    Enabled(ThinkingConfigEnabled),

    #[serde(rename = "disabled")]
    Disabled(ThinkingConfigDisabled),
}

#[derive(Serialize, Deserialize)]
pub struct ThinkingConfigEnabled {
    /// Determines how many tokens Claude can use for its internal reasoning process
    pub budget_tokens: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ThinkingConfigDisabled {}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ToolChoice {
    #[serde(rename = "auto")]
    Auto(ToolChoiceAuto),

    #[serde(rename = "any")]
    Any(ToolChoiceAny),

    #[serde(rename = "tool")]
    Tool(ToolChoiceTool),

    #[serde(rename = "none")]
    None(ToolChoiceNone),
}

#[derive(Serialize, Deserialize)]
pub struct ToolChoiceAuto {
    /// Whether to disable parallel tool use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable_parallel_tool_use: Option<bool>,
}

#[derive(Serialize, Deserialize)]
pub struct ToolChoiceAny {
    /// Whether to disable parallel tool use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable_parallel_tool_use: Option<bool>,
}

#[derive(Serialize, Deserialize)]
pub struct ToolChoiceTool {
    /// Whether to disable parallel tool use
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable_parallel_tool_use: Option<bool>,

    /// The name of the tool to use
    pub name: String,
}

#[derive(Serialize, Deserialize)]
pub struct ToolChoiceNone {}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToolUnion {
    Tool(Tool),
    BashTool20250124(BashTool20250124),
    TextEditor20250124(TextEditor20250124),
    TextEditor20250429(TextEditor20250429),
    TextEditor20250728(TextEditor20250728),
    WebSearchTool20250305(WebSearchTool20250305),
}

#[derive(Serialize, Deserialize)]
pub struct Tool {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    /// Description of what this tool does
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// JSON schema for this tool's input
    pub input_schema: InputSchema,

    /// Name of the tool
    pub name: String,

    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub type_field: Option<ToolType>,
}

#[derive(Serialize, Deserialize)]
pub enum ToolType {
    #[serde(rename = "custom")]
    Custom,
}

#[derive(Serialize, Deserialize)]
pub struct BashTool20250124 {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    pub name: String,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
pub struct TextEditor20250124 {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    pub name: String,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
pub struct TextEditor20250429 {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    pub name: String,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
pub struct TextEditor20250728 {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    /// Maximum number of characters to display when viewing a file
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_characters: Option<u32>,

    pub name: String,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
pub struct WebSearchTool20250305 {
    /// If provided, only these domains will be included in results
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_domains: Option<Vec<String>>,

    /// If provided, these domains will never appear in results
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blocked_domains: Option<Vec<String>>,

    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    /// Maximum number of times the tool can be used in the API request
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_uses: Option<u32>,

    pub name: String,

    #[serde(rename = "type")]
    pub type_field: String,

    /// Parameters for the user's location
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_location: Option<UserLocation>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ContentBlock {
    #[serde(rename = "text")]
    Text(ResponseTextBlock),

    #[serde(rename = "thinking")]
    Thinking(ResponseThinkingBlock),

    #[serde(rename = "redacted_thinking")]
    RedactedThinking(ResponseRedactedThinkingBlock),

    #[serde(rename = "tool_use")]
    ToolUse(ResponseToolUseBlock),

    #[serde(rename = "server_tool_use")]
    ServerToolUse(ResponseServerToolUseBlock),

    #[serde(rename = "web_search_tool_result")]
    WebSearchToolResult(ResponseWebSearchToolResultBlock),
}

#[derive(Serialize, Deserialize)]
pub enum StopReason {
    #[serde(rename = "end_turn")]
    EndTurn,
    #[serde(rename = "max_tokens")]
    MaxTokens,
    #[serde(rename = "stop_sequence")]
    StopSequence,
    #[serde(rename = "tool_use")]
    ToolUse,
    #[serde(rename = "pause_turn")]
    PauseTurn,
    #[serde(rename = "refusal")]
    Refusal,
}

#[derive(Serialize, Deserialize)]
pub struct Usage {
    /// Breakdown of cached tokens by TTL
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_creation: Option<CacheCreation>,

    /// The number of input tokens used to create the cache entry
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_creation_input_tokens: Option<u32>,

    /// The number of input tokens read from the cache
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_read_input_tokens: Option<u32>,

    /// The number of input tokens which were used
    pub input_tokens: u32,

    /// The number of output tokens which were used
    pub output_tokens: u32,

    /// The number of server tool requests
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_tool_use: Option<ServerToolUsage>,

    /// If the request used the priority, standard, or batch tier
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_tier: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct CacheCreation {
    /// The number of input tokens used to create the 1 hour cache entry
    #[serde(default)]
    pub ephemeral_1h_input_tokens: u32,

    /// The number of input tokens used to create the 5 minute cache entry
    #[serde(default)]
    pub ephemeral_5m_input_tokens: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ServerToolUsage {
    /// The number of web search tool requests
    #[serde(default)]
    pub web_search_requests: u32,
}

#[derive(Serialize, Deserialize)]
pub struct MessageDelta {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop_reason: Option<StopReason>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop_sequence: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct MessageDeltaUsage {
    /// The cumulative number of input tokens used to create the cache entry
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_creation_input_tokens: Option<u32>,

    /// The cumulative number of input tokens read from the cache
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_read_input_tokens: Option<u32>,

    /// The cumulative number of input tokens which were used
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_tokens: Option<u32>,

    /// The cumulative number of output tokens which were used
    pub output_tokens: u32,

    /// The number of server tool requests
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_tool_use: Option<ServerToolUsage>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ContentBlockDelta {
    #[serde(rename = "text_delta")]
    TextDelta(TextContentBlockDelta),

    #[serde(rename = "input_json_delta")]
    InputJsonDelta(InputJsonContentBlockDelta),

    #[serde(rename = "citations_delta")]
    CitationsDelta(CitationsDelta),

    #[serde(rename = "thinking_delta")]
    ThinkingDelta(ThinkingContentBlockDelta),

    #[serde(rename = "signature_delta")]
    SignatureDelta(SignatureContentBlockDelta),
}

#[derive(Serialize, Deserialize)]
pub struct TextContentBlockDelta {
    pub text: String,
}

#[derive(Serialize, Deserialize)]
pub struct InputJsonContentBlockDelta {
    pub partial_json: String,
}

#[derive(Serialize, Deserialize)]
pub struct CitationsDelta {
    pub citation: ResponseCitation,
}

#[derive(Serialize, Deserialize)]
pub struct ThinkingContentBlockDelta {
    pub thinking: String,
}

#[derive(Serialize, Deserialize)]
pub struct SignatureContentBlockDelta {
    pub signature: String,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum InputContentBlock {
    #[serde(rename = "text")]
    Text(RequestTextBlock),

    #[serde(rename = "image")]
    Image(RequestImageBlock),

    #[serde(rename = "document")]
    Document(RequestDocumentBlock),

    #[serde(rename = "search_result")]
    SearchResult(RequestSearchResultBlock),

    #[serde(rename = "thinking")]
    Thinking(RequestThinkingBlock),

    #[serde(rename = "redacted_thinking")]
    RedactedThinking(RequestRedactedThinkingBlock),

    #[serde(rename = "tool_use")]
    ToolUse(RequestToolUseBlock),

    #[serde(rename = "tool_result")]
    ToolResult(RequestToolResultBlock),

    #[serde(rename = "server_tool_use")]
    ServerToolUse(RequestServerToolUseBlock),

    #[serde(rename = "web_search_tool_result")]
    WebSearchToolResult(RequestWebSearchToolResultBlock),
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum CacheControl {
    #[serde(rename = "ephemeral")]
    Ephemeral(CacheControlEphemeral),
}

#[derive(Serialize, Deserialize)]
pub struct CacheControlEphemeral {
    /// The time-to-live for the cache control breakpoint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum RequestCitation {
    #[serde(rename = "char_location")]
    CharLocation(RequestCharLocationCitation),

    #[serde(rename = "page_location")]
    PageLocation(RequestPageLocationCitation),

    #[serde(rename = "content_block_location")]
    ContentBlockLocation(RequestContentBlockLocationCitation),

    #[serde(rename = "web_search_result_location")]
    WebSearchResultLocation(RequestWebSearchResultLocationCitation),

    #[serde(rename = "search_result_location")]
    SearchResultLocation(RequestSearchResultLocationCitation),
}

#[derive(Serialize, Deserialize)]
pub struct RequestCharLocationCitation {
    pub cited_text: String,
    pub document_index: u32,
    pub document_title: Option<String>,
    pub end_char_index: i32,
    pub start_char_index: u32,
}

#[derive(Serialize, Deserialize)]
pub struct RequestPageLocationCitation {
    pub cited_text: String,
    pub document_index: u32,
    pub document_title: Option<String>,
    pub end_page_number: i32,
    pub start_page_number: u32,
}

#[derive(Serialize, Deserialize)]
pub struct RequestContentBlockLocationCitation {
    pub cited_text: String,
    pub document_index: u32,
    pub document_title: Option<String>,
    pub end_block_index: i32,
    pub start_block_index: u32,
}

#[derive(Serialize, Deserialize)]
pub struct RequestWebSearchResultLocationCitation {
    pub cited_text: String,
    pub encrypted_index: String,
    pub title: Option<String>,
    pub url: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestSearchResultLocationCitation {
    pub cited_text: String,
    pub end_block_index: i32,
    pub search_result_index: u32,
    pub source: String,
    pub start_block_index: u32,
    pub title: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct InputSchema {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<Value>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<Vec<String>>,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
pub struct UserLocation {
    /// The city of the user
    #[serde(skip_serializing_if = "Option::is_none")]
    pub city: Option<String>,

    /// The two letter ISO country code of the user
    #[serde(skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,

    /// The region of the user
    #[serde(skip_serializing_if = "Option::is_none")]
    pub region: Option<String>,

    /// The IANA timezone of the user
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timezone: Option<String>,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseTextBlock {
    /// Citations supporting the text block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub citations: Option<Vec<ResponseCitation>>,

    pub text: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseThinkingBlock {
    pub signature: String,
    pub thinking: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseRedactedThinkingBlock {
    pub data: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseToolUseBlock {
    pub id: String,
    pub input: Value,
    pub name: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseServerToolUseBlock {
    pub id: String,
    pub input: Value,
    pub name: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseWebSearchToolResultBlock {
    pub content: WebSearchToolResultContent,
    pub tool_use_id: String,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebSearchToolResultContent {
    Error(ResponseWebSearchToolResultError),
    Results(Vec<ResponseWebSearchResultBlock>),
}

#[derive(Serialize, Deserialize)]
pub struct ResponseWebSearchToolResultError {
    pub error_code: WebSearchToolResultErrorCode,

    #[serde(rename = "type")]
    pub type_field: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseWebSearchResultBlock {
    pub encrypted_content: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_age: Option<String>,

    pub title: String,

    #[serde(rename = "type", default = "default_web_search_result")]
    pub type_field: String,

    pub url: String,
}

fn default_web_search_result() -> String {
    "web_search_result".to_string()
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ResponseCitation {
    #[serde(rename = "char_location")]
    CharLocation(ResponseCharLocationCitation),

    #[serde(rename = "page_location")]
    PageLocation(ResponsePageLocationCitation),

    #[serde(rename = "content_block_location")]
    ContentBlockLocation(ResponseContentBlockLocationCitation),

    #[serde(rename = "web_search_result_location")]
    WebSearchResultLocation(ResponseWebSearchResultLocationCitation),

    #[serde(rename = "search_result_location")]
    SearchResultLocation(ResponseSearchResultLocationCitation),
}

#[derive(Serialize, Deserialize)]
pub struct ResponseCharLocationCitation {
    pub cited_text: String,
    pub document_index: u32,
    pub document_title: Option<String>,
    pub end_char_index: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_id: Option<String>,
    pub start_char_index: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ResponsePageLocationCitation {
    pub cited_text: String,
    pub document_index: u32,
    pub document_title: Option<String>,
    pub end_page_number: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_id: Option<String>,
    pub start_page_number: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseContentBlockLocationCitation {
    pub cited_text: String,
    pub document_index: u32,
    pub document_title: Option<String>,
    pub end_block_index: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_id: Option<String>,
    pub start_block_index: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseWebSearchResultLocationCitation {
    pub cited_text: String,
    pub encrypted_index: String,
    pub title: Option<String>,
    pub url: String,
}

#[derive(Serialize, Deserialize)]
pub struct ResponseSearchResultLocationCitation {
    pub cited_text: String,
    pub end_block_index: i32,
    pub search_result_index: u32,
    pub source: String,
    pub start_block_index: u32,
    pub title: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub enum WebSearchToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    InvalidToolInput,
    #[serde(rename = "unavailable")]
    Unavailable,
    #[serde(rename = "max_uses_exceeded")]
    MaxUsesExceeded,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "query_too_long")]
    QueryTooLong,
}

#[derive(Serialize, Deserialize)]
pub struct RequestImageBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    pub source: ImageSource,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ImageSource {
    #[serde(rename = "base64")]
    Base64(Base64ImageSource),

    #[serde(rename = "url")]
    Url(URLImageSource),
}

#[derive(Serialize, Deserialize)]
pub struct Base64ImageSource {
    pub data: String,
    pub media_type: String,
}

#[derive(Serialize, Deserialize)]
pub struct URLImageSource {
    pub url: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestDocumentBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub citations: Option<RequestCitationsConfig>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<String>,

    pub source: DocumentSource,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

#[derive(Serialize, Deserialize)]
pub struct RequestCitationsConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum DocumentSource {
    #[serde(rename = "base64")]
    Base64(Base64PDFSource),

    #[serde(rename = "text")]
    Text(PlainTextSource),

    #[serde(rename = "content")]
    Content(ContentBlockSource),

    #[serde(rename = "url")]
    Url(URLPDFSource),
}

#[derive(Serialize, Deserialize)]
pub struct Base64PDFSource {
    pub data: String,
    pub media_type: String,
}

#[derive(Serialize, Deserialize)]
pub struct PlainTextSource {
    pub data: String,
    pub media_type: String,
}

#[derive(Serialize, Deserialize)]
pub struct ContentBlockSource {
    pub content: ContentBlockSourceContent,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContentBlockSourceContent {
    String(String),
    Blocks(Vec<ContentBlockSourceItem>),
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ContentBlockSourceItem {
    #[serde(rename = "text")]
    Text(RequestTextBlock),

    #[serde(rename = "image")]
    Image(RequestImageBlock),
}

#[derive(Serialize, Deserialize)]
pub struct URLPDFSource {
    pub url: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestSearchResultBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub citations: Option<RequestCitationsConfig>,

    pub content: Vec<RequestTextBlock>,

    pub source: String,

    pub title: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestThinkingBlock {
    pub signature: String,
    pub thinking: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestRedactedThinkingBlock {
    pub data: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestToolUseBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    pub id: String,
    pub input: Value,
    pub name: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestToolResultBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<ToolResultContent>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_error: Option<bool>,

    pub tool_use_id: String,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToolResultContent {
    String(String),
    Blocks(Vec<ToolResultContentBlock>),
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ToolResultContentBlock {
    #[serde(rename = "text")]
    Text(RequestTextBlock),

    #[serde(rename = "image")]
    Image(RequestImageBlock),

    #[serde(rename = "search_result")]
    SearchResult(RequestSearchResultBlock),

    #[serde(rename = "document")]
    Document(RequestDocumentBlock),
}

#[derive(Serialize, Deserialize)]
pub struct RequestServerToolUseBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    pub id: String,
    pub input: Value,
    pub name: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestWebSearchToolResultBlock {
    /// Create a cache control breakpoint at this content block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<CacheControl>,

    pub content: RequestWebSearchToolResultContent,
    pub tool_use_id: String,
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestWebSearchToolResultContent {
    Results(Vec<RequestWebSearchResultBlock>),
    Error(RequestWebSearchToolResultError),
}

#[derive(Serialize, Deserialize)]
pub struct RequestWebSearchResultBlock {
    pub encrypted_content: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_age: Option<String>,

    pub title: String,

    #[serde(rename = "type")]
    pub type_field: String,

    pub url: String,
}

#[derive(Serialize, Deserialize)]
pub struct RequestWebSearchToolResultError {
    pub error_code: WebSearchToolResultErrorCode,

    #[serde(rename = "type")]
    pub type_field: String,
}
