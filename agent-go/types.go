package llmagent

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	llmsdk "github.com/hoangvvo/llm-sdk/sdk-go"
)

type AgentRequest[C any] struct {
	// The input items to the agent, such as LLM messages.
	Input []AgentItem `json:"input"`
	// Context is the value to be used during tool calling and building system instructions
	Context C `json:"context"`
}

type AgentResponse struct {
	// Items are items generated during the agent's execution, such as new
	// `ToolMessage` and `AssistantMessage`
	Output []AgentItem `json:"output"`

	// Content is the  final output content generated by the agent.
	Content []llmsdk.Part `json:"content"`

	// Model calls information, including usage and cost
	ModelCalls []ModelCallInfo `json:"model_calls"`
}

// Text extracts all text content from the final content, separated by a space.
func (r *AgentResponse) Text() string {
	var texts []string
	for _, part := range r.Content {
		if part.TextPart != nil {
			texts = append(texts, part.TextPart.Text)
		}
	}
	return strings.Join(texts, " ")
}

// AgentItem is an input for or output entry generated by the agent run.
// Only one of the fields will be non-nil.
type AgentItem struct {
	// A LLM message used in the run
	Message *llmsdk.Message `json:"_"`
}

func NewMessageAgentItem(message llmsdk.Message) AgentItem {
	return AgentItem{
		Message: &message,
	}
}

type AgentItemType string

const (
	AgentItemTypeMessage AgentItemType = "message"
)

func (r AgentItem) MarshalJSON() ([]byte, error) {
	if r.Message != nil {
		return json.Marshal(struct {
			Type AgentItemType `json:"type"`
			*llmsdk.Message
		}{
			Type:    AgentItemTypeMessage,
			Message: r.Message,
		})
	}
	return nil, errors.New("invalid RunItem")
}

func (r *AgentItem) UnmarshalJSON(data []byte) error {
	var aux struct {
		Type AgentItemType `json:"type"`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	switch aux.Type {
	case AgentItemTypeMessage:
		var msg llmsdk.Message
		if err := json.Unmarshal(data, &msg); err != nil {
			return err
		}
		r.Message = &msg
	default:
		return fmt.Errorf("unknown RunItem type: %s", aux.Type)
	}
	return nil
}

// ModelCallInfo track a call to the LLM and record its usage and cost.
type ModelCallInfo struct {
	Usage    *llmsdk.ModelUsage  `json:"usage"`
	Cost     *float64            `json:"cost"`
	ModelID  string              `json:"model_id"`
	Provider llmsdk.ProviderName `json:"provider"`
}

// AgentStreamEvent are stream events emitted by the agent during runStream call.
// Only one of the fields will be non-nil.
type AgentStreamEvent struct {
	Partial  *llmsdk.PartialModelResponse `json:"-"`
	Message  *llmsdk.Message              `json:"-"`
	Response *AgentResponse               `json:"-"`
}

func (e AgentStreamEvent) MarshalJSON() ([]byte, error) {
	if e.Partial != nil {
		return json.Marshal(struct {
			Type AgentStreamEventType `json:"type"`
			*llmsdk.PartialModelResponse
		}{
			Type:                 AgentStreamEventTypePartial,
			PartialModelResponse: e.Partial,
		})
	}
	if e.Message != nil {
		return json.Marshal(struct {
			Type AgentStreamEventType `json:"type"`
			*llmsdk.Message
		}{
			Type:    AgentStreamEventTypeMessage,
			Message: e.Message,
		})
	}
	if e.Response != nil {
		return json.Marshal(struct {
			Type AgentStreamEventType `json:"type"`
			*AgentResponse
		}{
			Type:          AgentStreamEventTypeResponse,
			AgentResponse: e.Response,
		})
	}
	return nil, errors.New("invalid AgentStreamEvent")
}

func (e *AgentStreamEvent) UnmarshalJSON(data []byte) error {
	var aux struct {
		Type AgentStreamEventType `json:"type"`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	switch aux.Type {
	case AgentStreamEventTypePartial:
		var partial llmsdk.PartialModelResponse
		if err := json.Unmarshal(data, &partial); err != nil {
			return err
		}
		e.Partial = &partial
	case AgentStreamEventTypeMessage:
		var msg llmsdk.Message
		if err := json.Unmarshal(data, &msg); err != nil {
			return err
		}
		e.Message = &msg
	case AgentStreamEventTypeResponse:
		var resp AgentResponse
		if err := json.Unmarshal(data, &resp); err != nil {
			return err
		}
		e.Response = &resp
	default:
		return fmt.Errorf("unknown AgentStreamEvent type: %s", aux.Type)
	}
	return nil
}

type AgentStreamEventType string

const (
	AgentStreamEventTypePartial  AgentStreamEventType = "partial"
	AgentStreamEventTypeMessage  AgentStreamEventType = "message"
	AgentStreamEventTypeResponse AgentStreamEventType = "response"
)

type AgentStream struct {
	C    <-chan *AgentStreamEvent
	errC <-chan error

	curr *AgentStreamEvent
	err  error
}

func NewAgentStream(c <-chan *AgentStreamEvent, errC <-chan error) *AgentStream {
	return &AgentStream{
		C:    c,
		errC: errC,
		curr: nil,
		err:  nil,
	}
}

// Next advances the stream and returns true if there is a next item.
func (s *AgentStream) Next() bool {
	select {
	case event, ok := <-s.C:
		if !ok {
			// Channel closed, check for error (non-blocking)
			select {
			case err := <-s.errC:
				s.err = err
			default:
				// No error available
			}
			return false
		}
		s.curr = event
		return true
	case err := <-s.errC:
		s.err = err
		return false
	}
}

// Current gets the most recent item after Next() returns true.
func (s *AgentStream) Current() *AgentStreamEvent {
	return s.curr
}

// Err returns the error encountered during streaming, if any.
func (s *AgentStream) Err() error {
	return s.err
}
