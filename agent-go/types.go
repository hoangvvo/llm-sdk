package llmagent

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	llmsdk "github.com/hoangvvo/llm-sdk/sdk-go"
	"github.com/hoangvvo/llm-sdk/sdk-go/utils/stream"
)

type AgentRequest[C any] struct {
	// The input items to the agent, such as LLM messages.
	Input []AgentItem `json:"input"`
	// Context is the value to be used during tool calling and building system instructions
	Context C `json:"context"`
}

type AgentResponse struct {
	// Items are items generated during the agent's execution, such as new
	// `ToolMessage` and `AssistantMessage`
	Output []AgentItem `json:"output"`

	// Content is the  final output content generated by the agent.
	Content []llmsdk.Part `json:"content"`
}

// Text extracts all text content from the final content, separated by a space.
func (r *AgentResponse) Text() string {
	var texts []string
	for _, part := range r.Content {
		if part.TextPart != nil {
			texts = append(texts, part.TextPart.Text)
		}
	}
	return strings.Join(texts, " ")
}

// AgentItem is an input for or output entry generated by the agent run.
// Only one of the fields will be non-nil.
type AgentItem struct {
	// A LLM message used in the run
	Message *llmsdk.Message `json:"-"`
	// A model response generated in the run
	Model *AgentItemModelResponse `json:"-"`
	// A tool call result generated during the run
	Tool *AgentItemTool `json:"-"`
}

func (r AgentItem) Type() AgentItemType {
	if r.Message != nil {
		return AgentItemTypeMessage
	}
	if r.Model != nil {
		return AgentItemTypeModel
	}
	if r.Tool != nil {
		return AgentItemTypeTool
	}
	return ""
}

// AgentItemTool represents a tool call item in the run output.
type AgentItemTool struct {
	ToolCallID string          `json:"tool_call_id"`
	ToolName   string          `json:"tool_name"`
	Input      json.RawMessage `json:"input"`
	Output     []llmsdk.Part   `json:"output"`
	IsError    bool            `json:"is_error"`
}

// AgentItemModelResponse represents a model response item in the run output.
type AgentItemModelResponse struct {
	*llmsdk.ModelResponse
}

func NewAgentItemMessage(message llmsdk.Message) AgentItem {
	return AgentItem{Message: &message}
}

func NewAgentItemModelResponse(response llmsdk.ModelResponse) AgentItem {
	return AgentItem{Model: &AgentItemModelResponse{ModelResponse: &response}}
}

func NewAgentItemTool(toolCallID, toolName string, input json.RawMessage, output []llmsdk.Part, isError bool) AgentItem {
	return AgentItem{Tool: &AgentItemTool{
		ToolCallID: toolCallID,
		ToolName:   toolName,
		Input:      input,
		Output:     output,
		IsError:    isError,
	}}
}

type AgentItemType string

const (
	AgentItemTypeMessage AgentItemType = "message"
	AgentItemTypeModel   AgentItemType = "model"
	AgentItemTypeTool    AgentItemType = "tool"
)

func (r AgentItem) MarshalJSON() ([]byte, error) {
	if r.Message != nil {
		return json.Marshal(struct {
			Type AgentItemType `json:"type"`
			*llmsdk.Message
		}{
			Type:    AgentItemTypeMessage,
			Message: r.Message,
		})
	}
	if r.Model != nil {
		return json.Marshal(struct {
			Type AgentItemType `json:"type"`
			*AgentItemModelResponse
		}{
			Type:                   AgentItemTypeModel,
			AgentItemModelResponse: r.Model,
		})
	}
	if r.Tool != nil {
		return json.Marshal(struct {
			Type AgentItemType `json:"type"`
			*AgentItemTool
		}{
			Type:          AgentItemTypeTool,
			AgentItemTool: r.Tool,
		})
	}
	return nil, errors.New("invalid AgentItem")
}

func (r *AgentItem) UnmarshalJSON(data []byte) error {
	var aux struct {
		Type AgentItemType `json:"type"`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	switch aux.Type {
	case AgentItemTypeMessage:
		var msg llmsdk.Message
		if err := json.Unmarshal(data, &msg); err != nil {
			return err
		}
		r.Message = &msg
	case AgentItemTypeModel:
		var response AgentItemModelResponse
		if err := json.Unmarshal(data, &response); err != nil {
			return err
		}
		r.Model = &response
	case AgentItemTypeTool:
		var tool AgentItemTool
		if err := json.Unmarshal(data, &tool); err != nil {
			return err
		}
		r.Tool = &tool
	default:
		return fmt.Errorf("unknown AgentItem type: %s", aux.Type)
	}
	return nil
}

// AgentStreamEvent are stream events emitted by the agent during runStream call.
// Only one of the fields will be non-nil.
type AgentStreamEvent struct {
	Partial  *llmsdk.PartialModelResponse `json:"-"`
	Item     *AgentItem                   `json:"-"`
	Response *AgentResponse               `json:"-"`
}

func (e AgentStreamEvent) MarshalJSON() ([]byte, error) {
	if e.Partial != nil {
		return json.Marshal(struct {
			Event AgentStreamEventType `json:"event"`
			*llmsdk.PartialModelResponse
		}{
			Event:                AgentStreamEventTypePartial,
			PartialModelResponse: e.Partial,
		})
	}
	if e.Item != nil {
		// we cannot marshal r.Item directly because AgentItem
		// also implements MarshalJSON, which would lead to overriding
		// Create a type alias that doesn't have MarshalJSON
		// Let AgentItem marshal itself
		itemJSON, err := json.Marshal(e.Item)
		if err != nil {
			return nil, err
		}

		// Marshal just the event field
		eventJSON, err := json.Marshal(AgentStreamEventTypeItem)
		if err != nil {
			return nil, err
		}

		// Manually construct the JSON by inserting the event field
		// itemJSON looks like: {"type":"...", ...}
		// We want: {"event":"item","type":"...", ...}

		// Convert to string for manipulation
		itemStr := string(itemJSON)

		// Build the final JSON string
		result := fmt.Sprintf(`{"event":%s,%s`, eventJSON, itemStr[1:])

		return []byte(result), nil
	}
	if e.Response != nil {
		return json.Marshal(struct {
			Event AgentStreamEventType `json:"event"`
			*AgentResponse
		}{
			Event:         AgentStreamEventTypeResponse,
			AgentResponse: e.Response,
		})
	}
	return nil, errors.New("invalid AgentStreamEvent")
}

func (e *AgentStreamEvent) UnmarshalJSON(data []byte) error {
	var aux struct {
		Event AgentStreamEventType `json:"event"`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	switch aux.Event {
	case AgentStreamEventTypePartial:
		var partial llmsdk.PartialModelResponse
		if err := json.Unmarshal(data, &partial); err != nil {
			return err
		}
		e.Partial = &partial
	case AgentStreamEventTypeItem:
		var item AgentItem
		if err := json.Unmarshal(data, &item); err != nil {
			return err
		}
		e.Item = &item
	case AgentStreamEventTypeResponse:
		var resp AgentResponse
		if err := json.Unmarshal(data, &resp); err != nil {
			return err
		}
		e.Response = &resp
	default:
		return fmt.Errorf("unknown AgentStreamEvent event: %s", aux.Event)
	}
	return nil
}

type AgentStreamEventType string

const (
	AgentStreamEventTypePartial  AgentStreamEventType = "partial"
	AgentStreamEventTypeItem     AgentStreamEventType = "item"
	AgentStreamEventTypeResponse AgentStreamEventType = "response"
)

type AgentStream = stream.Stream[*AgentStreamEvent]
