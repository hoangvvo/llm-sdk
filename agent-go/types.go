package llmagent

import (
	"encoding/json"
	"errors"
	"fmt"

	llmsdk "github.com/hoangvvo/llm-sdk/sdk-go"
)

type AgentRequest[C any] struct {
	// Messages are input messages to the agent.
	Messages []llmsdk.Message `json:"messages"`
	// Context is the value to be used during tool calling and building system instructions
	Context C `json:"context"`
}

type AgentResponse struct {
	// Items are items generated during the agent's execution, such as new
	// `ToolMessage` and `AssistantMessage`
	Items []RunItem `json:"items"`

	// Content is the last assistant output content generated by the agent.
	Content []llmsdk.Part `json:"content"`
}

// RunItem are items generated during the run.
// Only one of the fields will be non-nil.
type RunItem struct {
	Message *llmsdk.Message `json:"_"`
}

type RunItemType string

const (
	RunItemTypeMessage RunItemType = "message"
)

func (r RunItem) MarshalJSON() ([]byte, error) {
	if r.Message != nil {
		return json.Marshal(struct {
			Type RunItemType `json:"type"`
			*llmsdk.Message
		}{
			Type:    RunItemTypeMessage,
			Message: r.Message,
		})
	}
	return nil, errors.New("invalid RunItem")
}

func (r *RunItem) UnmarshalJSON(data []byte) error {
	var aux struct {
		Type RunItemType `json:"type"`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	switch aux.Type {
	case RunItemTypeMessage:
		var msg llmsdk.Message
		if err := json.Unmarshal(data, &msg); err != nil {
			return err
		}
		r.Message = &msg
	default:
		return fmt.Errorf("unknown RunItem type: %s", aux.Type)
	}
	return nil
}

type AgentStreamEventType string

const (
	AgentStreamEventTypePartial  AgentStreamEventType = "partial"
	AgentStreamEventTypeMessage  AgentStreamEventType = "message"
	AgentStreamEventTypeResponse AgentStreamEventType = "response"
)

// AgentStreamEvent are events received during streaming.
// Only one of the fields will be non-nil.
type AgentStreamEvent struct {
	Partial  *llmsdk.PartialModelResponse `json:"-"`
	Message  *llmsdk.Message              `json:"-"`
	Response *AgentResponse               `json:"-"`
}

func (e AgentStreamEvent) MarshalJSON() ([]byte, error) {
	if e.Partial != nil {
		return json.Marshal(struct {
			Type AgentStreamEventType `json:"type"`
			*llmsdk.PartialModelResponse
		}{
			Type:                 AgentStreamEventTypePartial,
			PartialModelResponse: e.Partial,
		})
	}
	if e.Message != nil {
		return json.Marshal(struct {
			Type AgentStreamEventType `json:"type"`
			*llmsdk.Message
		}{
			Type:    AgentStreamEventTypeMessage,
			Message: e.Message,
		})
	}
	if e.Response != nil {
		return json.Marshal(struct {
			Type AgentStreamEventType `json:"type"`
			*AgentResponse
		}{
			Type:          AgentStreamEventTypeResponse,
			AgentResponse: e.Response,
		})
	}
	return nil, errors.New("invalid AgentStreamEvent")
}

func (e *AgentStreamEvent) UnmarshalJSON(data []byte) error {
	var aux struct {
		Type AgentStreamEventType `json:"type"`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	switch aux.Type {
	case AgentStreamEventTypePartial:
		var partial llmsdk.PartialModelResponse
		if err := json.Unmarshal(data, &partial); err != nil {
			return err
		}
		e.Partial = &partial
	case AgentStreamEventTypeMessage:
		var msg llmsdk.Message
		if err := json.Unmarshal(data, &msg); err != nil {
			return err
		}
		e.Message = &msg
	case AgentStreamEventTypeResponse:
		var resp AgentResponse
		if err := json.Unmarshal(data, &resp); err != nil {
			return err
		}
		e.Response = &resp
	default:
		return fmt.Errorf("unknown AgentStreamEvent type: %s", aux.Type)
	}
	return nil
}

type AgentStream struct {
	C    <-chan *AgentStreamEvent
	errC <-chan error

	curr *AgentStreamEvent
	err  error
}

func NewAgentStream(c <-chan *AgentStreamEvent, errC <-chan error) *AgentStream {
	return &AgentStream{
		C:    c,
		errC: errC,
		curr: nil,
		err:  nil,
	}
}

// Next advances the stream and returns true if there is a next item.
func (s *AgentStream) Next() bool {
	select {
	case event, ok := <-s.C:
		if !ok {
			// Channel closed, check for error (non-blocking)
			select {
			case err := <-s.errC:
				s.err = err
			default:
				// No error available
			}
			return false
		}
		s.curr = event
		return true
	case err := <-s.errC:
		s.err = err
		return false
	}
}

// Current gets the most recent item after Next() returns true.
func (s *AgentStream) Current() *AgentStreamEvent {
	return s.curr
}

// Err returns the error encountered during streaming, if any.
func (s *AgentStream) Err() error {
	return s.err
}
