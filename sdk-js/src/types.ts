/**
 * The encoding of the audio.
 */
export type AudioEncoding =
  | "linear16"
  | "flac"
  | "mulaw"
  | "alaw"
  | "aac"
  | "mp3"
  | "opus";
/**
 * The container format of the audio.
 */
export type AudioContainer = "wav" | "ogg" | "flac" | "webm";
export type Part =
  | TextPart
  | ImagePart
  | AudioPart
  | ToolCallPart
  | ToolResultPart;
export type Message = UserMessage | AssistantMessage | ToolMessage;
export type Modality = "text" | "audio";
/**
 * A metadata property that describes the capability of the model.
 */
export type LanguageModelCapability =
  | "structured-output"
  | "function-calling"
  | "structured-output-strict"
  | "audio-input"
  | "audio-output"
  | "image-input"
  | "image-output";

export interface LlmSdk {
  [k: string]: unknown;
}
/**
 * A part of the message that contains text.
 */
export interface TextPart {
  type: "text";
  text: string;
  /**
   * The ID of the part, if applicable.
   */
  id?: string;
}
/**
 * A part of the message that contains an image.
 */
export interface ImagePart {
  type: "image";
  /**
   * The MIME type of the image. E.g. "image/jpeg", "image/png".
   */
  mimeType: string;
  /**
   * The base64-encoded image data.
   */
  imageData: string;
  /**
   * The width of the image in pixels.
   */
  width?: number;
  /**
   * The height of the image in pixels.
   */
  height?: number;
  /**
   * The ID of the part, if applicable.
   */
  id?: string;
}
/**
 * A part of the message that contains an audio.
 */
export interface AudioPart {
  type: "audio";
  container?: AudioContainer;
  /**
   * The base64-encoded audio data.
   */
  audioData: string;
  encoding?: AudioEncoding;
  /**
   * The sample rate of the audio. E.g. 44100, 48000.
   */
  sampleRate?: number;
  /**
   * The number of channels of the audio. E.g. 1, 2.
   */
  channels?: number;
  /**
   * The transcript of the audio.
   */
  transcript?: string;
  /**
   * The ID of the part, if applicable.
   */
  id?: string;
}
/**
 * A part of the message that represents a call to a tool the model wants to use.
 */
export interface ToolCallPart {
  type: "tool-call";
  /**
   * The ID of the tool call, used to match the tool result with the tool call.
   */
  toolCallId: string;
  /**
   * The name of the tool to call.
   */
  toolName: string;
  /**
   * The arguments to pass to the tool.
   */
  args: {
    [k: string]: unknown;
  } | null;
  /**
   * The ID of the part, if applicable. This might not be the same as the toolCallId.
   */
  id?: string;
}
/**
 * A part of the message that represents the result of a tool call.
 */
export interface ToolResultPart {
  type: "tool-result";
  /**
   * The ID of the tool call from previous assistant message.
   */
  toolCallId: string;
  /**
   * The name of the tool that was called.
   */
  toolName: string;
  /**
   * The result of the tool call.
   */
  result:
    | {
        [k: string]: unknown;
      }
    | unknown[];
  /**
   * Marks the tool result as an error.
   */
  isError?: boolean;
}
/**
 * Represents a message sent by the user.
 */
export interface UserMessage {
  role: "user";
  content: (TextPart | ImagePart | AudioPart)[];
}
/**
 * Represents a message generated by the model.
 */
export interface AssistantMessage {
  role: "assistant";
  content: (TextPart | ToolCallPart | AudioPart)[];
}
export interface TextPartDelta {
  type: "text";
  text: string;
  /**
   * The ID of the part, if applicable.
   */
  id?: string;
}
export interface ToolCallPartDelta {
  type: "tool-call";
  /**
   * The ID of the tool call, used to match the tool result with the tool call.
   */
  toolCallId?: string;
  /**
   * The name of the tool to call.
   */
  toolName?: string;
  /**
   * The partial JSON string of the arguments to pass to the tool.
   */
  args?: string;
  /**
   * The ID of the part, if applicable. This might not be the same as the toolCallId.
   */
  id?: string;
}
export interface AudioPartDelta {
  type: "audio";
  /**
   * The base64-encoded audio data.
   */
  audioData?: string;
  container?: AudioContainer;
  encoding?: AudioEncoding;
  /**
   * The sample rate of the audio. E.g. 44100, 48000.
   */
  sampleRate?: number;
  /**
   * The number of channels of the audio. E.g. 1, 2.
   */
  channels?: number;
  /**
   * The transcript of the audio.
   */
  transcript?: string;
  /**
   * The ID of the part, if applicable.
   */
  id?: string;
}
export interface ContentDelta {
  index: number;
  part: TextPartDelta | ToolCallPartDelta | AudioPartDelta;
}
/**
 * Represents a JSON schema.
 */
export interface JSONSchema {
  [k: string]: unknown;
}
/**
 * Represents a tool that can be used by the model.
 */
export interface Tool {
  /**
   * The name of the tool.
   */
  name: string;
  /**
   * A description of the tool.
   */
  description: string;
  /**
   * The JSON schema of the parameters that the tool accepts. The type must be "object".
   */
  parameters: JSONSchema | null;
}
/**
 * Represents tool result in the message history.
 */
export interface ToolMessage {
  role: "tool";
  content: ToolResultPart[];
}
/**
 * Represents the token usage of the model.
 */
export interface ModelTokensDetail {
  textTokens?: number;
  cachedTextTokens?: number;
  audioTokens?: number;
  cachedAudioTokens?: number;
  imageTokens?: number;
  cachedImageTokens?: number;
}
/**
 * Represents the token usage of the model.
 */
export interface ModelUsage {
  inputTokens: number;
  outputTokens: number;
  inputTokensDetail?: ModelTokensDetail;
  outputTokensDetail?: ModelTokensDetail;
}
/**
 * Represents the response generated by the model.
 */
export interface ModelResponse {
  content: (TextPart | ToolCallPart | AudioPart)[];
  usage?: ModelUsage;
  /**
   * The cost of the response.
   */
  cost?: number;
}
export interface PartialModelResponse {
  delta: ContentDelta;
}
/**
 * The model will automatically choose the tool to use or not use any tools.
 */
export interface ToolChoiceAuto {
  type: "auto";
}
/**
 * The model will not use any tools.
 */
export interface ToolChoiceNone {
  type: "none";
}
/**
 * The model will be forced to use a tool.
 */
export interface ToolChoiceRequired {
  type: "required";
}
/**
 * The model will use the specified tool.
 */
export interface ToolChoiceTool {
  type: "tool";
  toolName: string;
}
export interface ResponseFormatText {
  type: "text";
}
export interface ResponseFormatJson {
  type: "json";
  schema?: JSONSchema;
}
export interface LanguageModelInput {
  /**
   * A system prompt is a way of providing context and instructions to the model
   */
  systemPrompt?: string;
  /**
   * A list of messages comprising the conversation so far.
   */
  messages: Message[];
  /**
   * Definitions of tools that the model may use.
   */
  tools?: Tool[];
  /**
   * Determines how the model should choose which tool to use. "auto" - The model will automatically choose the tool to use or not use any tools. "none" - The model will not use any tools. "required" - The model will be forced to use a tool. { type: "tool", toolName: "toolName" } - The model will use the specified tool.
   */
  toolChoice?:
    | ToolChoiceAuto
    | ToolChoiceNone
    | ToolChoiceRequired
    | ToolChoiceTool;
  /**
   * The format that the model must output
   */
  responseFormat?: ResponseFormatJson | ResponseFormatText;
  /**
   * The maximum number of tokens that can be generated in the chat completion.
   */
  maxTokens?: number;
  /**
   * Amount of randomness injected into the response. Ranges from 0.0 to 1.0
   */
  temperature?: number;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass Ranges from 0.0 to 1.0
   */
  topP?: number;
  /**
   * Only sample from the top K options for each subsequent token. Used to remove "long tail" low probability responses. Ranges from 0.0 to 1.0
   */
  topK?: number;
  /**
   * Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number;
  /**
   * Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number;
  /**
   * The seed (integer), if set and supported by the model, to enable deterministic results.
   */
  seed?: number;
  /**
   * The modalities that the model should support.
   */
  modalities?: Modality[];
  /**
   * Extra options that the model may support.
   */
  extra?: {
    [k: string]: unknown;
  };
}
/**
 * A metadata property that describes the pricing of the model.
 */
export interface LanguageModelPricing {
  /**
   * The cost in USD per single text token for input.
   */
  inputCostPerTextToken?: number;
  /**
   * The cost in USD per single cached text token for input.
   */
  inputCostPerCachedTextToken?: number;
  /**
   * The cost in USD per single text token for output.
   */
  outputCostPerTextToken?: number;
  /**
   * The cost in USD per single audio token for input.
   */
  inputCostPerAudioToken?: number;
  /**
   * The cost in USD per single cached audio token for input.
   */
  inputCostPerCachedAudioToken?: number;
  /**
   * The cost in USD per single audio token for output.
   */
  outputCostPerAudioToken?: number;
  /**
   * The cost in USD per single image token for input.
   */
  inputCostPerImageToken?: number;
  /**
   * The cost in USD per single cached image token for input.
   */
  inputCostPerCachedImageToken?: number;
  /**
   * The cost in USD per single image token for output.
   */
  outputCostPerImageToken?: number;
}
